
-- This is the lua code associated with t-pcontext.mkxl file

local tInsert    = table.insert
local tRemove    = table.remove
local tSerialize = table.serialize
local pprint     = require('pprint')

thirddata            = thirddata            or { }
thirddata.pcontext   = thirddata.pcontext   or { }

local pcontext       = thirddata.pcontext

pcontext.subDocs     = pcontext.subDocs     or { }
local subDocs        = pcontext.subDocs

pcontext.subDocOrder = pcontext.subDocOrder or { }
local subDocOrder    = pcontext.subDocOrder

pcontext.cmdList     = pcontext.cmdList     or { }
local cmdList        = pcontext.cmdList

local function initializer()
  print("HELLO FROM PConTeXt initializer!")
end

local function finalizer()
  print("GOOD BYE FROM PConTeXt initializer!")
end

job.register(
  'thirddata.pcontext.subDocs',
  'thirddata.pcontext.subDocs',
  initializer, finalizer
)

-- Consider using `job.loadother` and using tables.accesstable to retrieve 
-- the required data from the returned utilitydata. The problem with this 
-- approach is that the *.tuc file will be loaded an other time.

-- local utilitydata = job.loadother(tex.jobname..'.tuc')
-- local subDocs = 
--   tables.accesstable('utilitydata.pcontext.subDocs', utilitydata)

-- Actually we do not need the job.load....

-- Flow of data:

-- 1. On each context run we collect a sequence of required commands for a 
-- given subDocument. This is saved by the registered `job.save` (and 
-- ignored by any subsequent `job.load`). 

-- 2. The resulting sequence is then taken from the indvidual *.tuc files 
-- and harmonized by the compile script and saved into the (master) plua 
-- file. 

-- 3. When pcontext loads the (master) plua file and walks through the 
-- sequence. 

local function recordEnvironment(envName)
  tInsert(cmdList, { "environment",  envName } )
end

pcontext.recordEnvironment = recordEnvironment

local function recordSectionBlock(blockName, blockOptions)
  tInsert(cmdList, { blockName, blockOptions } )
end

pcontext.recordSectionBlock = recordSectionBlock

local function recordDocument(docName, docOptions)
  tInsert(cmdList, { docName, docOptions } )
end

pcontext.recordDocument = recordDocument

local function recordSubDocument(subDocumentName)
  local i = 0
  local subDocInstanceName = subDocumentName..'-'..i
  while subDocs[subDocInstanceName] do
    i = i + 1
    subDocInstanceName = subDocumentName..'-'..i
  end
  subDocs[subDocInstanceName] = {
    ["firstPage"] = 0,
    ["numPages"]  = 0,
    ["document"]  = subDocumentName
  }
  tInsert(subDocOrder, subDocInstanceName)
  tInsert(cmdList, { "component", subDocInstanceName } )
end

pcontext.recordSubDocument = recordSubDocument

luatex.registerstopactions(function()

  -- only (re)create the *.plua file IF we are in `extract` mode
  if tex.modes["extract"] then
    pcontext.jobname = tex.jobname
    local jobname    = pcontext.jobname

    local randomseedStr = tostring(job.variables.tobesaved.randomseed)
    
    local f = io.open(tex.jobname..'.plua', 'w')
    if f then
      f:write("-- This is the plua data file for the Parallel ConTeXt build of "..jobname.."\n")
      f:write("-- This file has been autogenerated -- do not edit\n\n")
    
      f:write("local pcontext       = { }\n\n")

      f:write("pcontext.jobname=\""..jobname.."\"\n\n")
      
      f:write("pcontext.lastRun=0\n\n")
    
      f:write("pcontext.randomseed="..randomseedStr.."\n\n")
      
      f:write(tSerialize(subDocOrder, "pcontext.subDocOrder", true), "\n\n")
    
      f:write(tSerialize(subDocs, "pcontext.subDocs", true), "\n\n")
      
      f:write(tSerialize(cmdList, "pcontext.cmdList", true), "\n\n")
    
      f:write("return pcontext")
      f:close()
    end
  end
end)

----------------------------------------------------------------------
