
-- This is the lua code associated with t-pcontext.mkxl file

local tInsert    = table.insert
local tRemove    = table.remove
local tSerialize = table.serialize
local pprint     = require('pprint')

thirddata            = thirddata            or { }
thirddata.pcontext   = thirddata.pcontext   or { }

local pcontext       = thirddata.pcontext

pcontext.subDocs     = pcontext.subDocs     or { }
local subDocs        = pcontext.subDocs

pcontext.subDocOrder = pcontext.subDocOrder or { }
local subDocOrder    = pcontext.subDocOrder

pcontext.cmdList     = pcontext.cmdList     or { }
local cmdList        = pcontext.cmdList

-- local function initializer()
--   print("HELLO FROM PConTeXt initializer!")
-- end

-- local function finalizer()
--   print("GOOD BYE FROM PConTeXt initializer!")
-- end

job.register(
  'thirddata.pcontext.subDocs',
  'thirddata.pcontext.subDocs'
--  initializer, finalizer
)

-- Consider using `job.loadother` and using tables.accesstable to retrieve 
-- the required data from the returned utilitydata. The problem with this 
-- approach is that the *.tuc file will be loaded an other time.

-- local utilitydata = job.loadother(tex.jobname..'.tuc')
-- local subDocs = 
--   tables.accesstable('utilitydata.pcontext.subDocs', utilitydata)

-- Actually we do not need the job.load....

-- Flow of data:

-- 1. On each context run we collect a sequence of required commands for a 
-- given subDocument. This is saved by the registered `job.save` (and 
-- ignored by any subsequent `job.load`). 

-- 2. The resulting sequence is then taken from the indvidual *.tuc files 
-- and harmonized by the compile script and saved into the (master) plua 
-- file. 

-- 3. When pcontext loads the (master) plua file and walks through the 
-- sequence. 

local function recordEnvironment(envName)
  tInsert(cmdList, { "environment",  envName } )
end

pcontext.recordEnvironment = recordEnvironment

local function recordSectionBlock(blockName, blockOptions)
  tInsert(cmdList, { blockName, blockOptions } )
end

pcontext.recordSectionBlock = recordSectionBlock

local function recordDocument(docName, docOptions)
  tInsert(cmdList, { docName, docOptions } )
end

pcontext.recordDocument = recordDocument

local function recordSubDocument(subDocumentName)
  local i = 0
  local subDocInstanceName = subDocumentName..'-'..i
  while subDocs[subDocInstanceName] do
    i = i + 1
    subDocInstanceName = subDocumentName..'-'..i
  end
  subDocs[subDocInstanceName] = {
    ["firstPage"] = 0,
    ["lastPage"] = 0,
    ["numPages"]  = 0,
    ["document"]  = subDocumentName
  }
  tInsert(subDocOrder, subDocInstanceName)
  tInsert(cmdList, { "component", subDocInstanceName } )
end

pcontext.recordSubDocument = recordSubDocument

luatex.registerstopactions(function()

  -- only (re)create the *.plua file IF we are in `extract` mode
  if tex.modes["extract"] then
    pcontext.jobname = tex.jobname
    local jobname    = pcontext.jobname

    local randomseedStr = tostring(job.variables.tobesaved.randomseed)
    
    local f = io.open(tex.jobname..'.plua', 'w')
    if f then
      f:write("-- This is the plua data file for the Parallel ConTeXt build of "..jobname.."\n")
      f:write("-- This file has been autogenerated -- do not edit\n\n")
    
      f:write("local pcontext       = { }\n\n")

      f:write("pcontext.jobname=\""..jobname.."\"\n\n")
      
      f:write("pcontext.lastRun=0\n\n")
    
      f:write("pcontext.randomseed="..randomseedStr.."\n\n")
      
      f:write(tSerialize(subDocOrder, "pcontext.subDocOrder", true), "\n\n")
    
      f:write(tSerialize(subDocs, "pcontext.subDocs", true), "\n\n")
      
      f:write(tSerialize(cmdList, "pcontext.cmdList", true), "\n\n")
    
      f:write("return pcontext")
      f:close()
    end
  end
end)

----------------------------------------------------------------------

local function firstPage(subDocName)
  print(">>>>> firstPage", subDocName)
  subDocs[subDocName] = subDocs[subDocName] or { }
  pprint(subDocs[subDocName])
  subDocs[subDocName].firstPage = tex.getcount('realpageno')
end

pcontext.firstPage = firstPage

local function lastPage(subDocName)
  print(">>>>>> lastPage", subDocName)
  subDocs[subDocName] = subDocs[subDocName] or { }
  pprint(subDocs[subDocName])
  subDocs[subDocName].lastPage = tex.getcount('realpageno')
  subDocs[subDocName].numPages = 
    subDocs[subDocName].lastPage -
    subDocs[subDocName].firstPage -- + 1

end

pcontext.lastPage = lastPage
